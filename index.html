<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RXVEN.SYNTH)</title>
    <style>
        /* CSS Styles (largely same as v4, minor tweaks if any for clarity) */
        body {
            font-family: 'Arial', sans-serif; background-color: #222; color: #eee;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh; margin: 0; user-select: none;
        }
        .status-bar { display: flex; justify-content: space-between; width: 95%; max-width: 1300px; margin-bottom: 10px;}
        .midi-status, .main-message {
            background-color: #333; color: #fff; padding: 8px 12px; border-radius: 5px;
            font-size: 0.9em; text-align: center;
        }
        .midi-status { min-width: 250px; }
        .main-message { flex-grow: 1; margin-left: 10px; }

        .synth-container {
            background-color: #e0e0e0; border: 2px solid #555; border-radius: 10px;
            padding: 15px; width: 95%; max-width: 1300px; 
            box-shadow: 0 0 20px rgba(0,0,0,0.5); color: #333;
        }
        .panel-row { display: flex; justify-content: space-around; align-items: flex-start; margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 10px; }
        .panel-row:last-child { border-bottom: none; margin-bottom: 0; }
        .section { border: 1px solid #bbb; border-radius: 5px; padding: 8px; margin: 4px; background-color: #f0f0f0; text-align: center; flex-basis: 0; flex-grow: 1; min-width: 130px; }
        .section h4 { margin-top: 0; margin-bottom: 8px; font-size: 0.85em; color: #555; text-transform: uppercase; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
        .control-group { margin-bottom: 8px; display: flex; flex-direction: column; align-items: center; }
        label { font-size: 0.7em; margin-bottom: 2px; color: #666; white-space: nowrap;}
        .knob { width: 45px; height: 45px; border-radius: 50%; background-color: #777; border: 2px solid #555; position: relative; cursor: grab; display: flex; justify-content: center; align-items: center; }
        .knob-indicator { width: 3px; height: 13px; background-color: #ddd; position: absolute; top: 4px; left: calc(50% - 1.5px); border-radius: 1.5px; transform-origin: 50% 18.5px; }
        .small-knob { width: 30px; height: 30px; }
        .small-knob .knob-indicator { height: 9px; top: 3px; transform-origin: 50% 12px; }
        
        .button { background-color: #999; color: #fff; border: 1px solid #666; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.75em; margin: 2px; }
        .button.active, .button.recording { background-color: #ff4500; box-shadow: 0 0 6px #ff4500; }
        .button.playing { background-color: #32cd32; box-shadow: 0 0 6px #32cd32; }
        .display { background-color: #2a2a2a; color: #0f0; padding: 4px; border-radius: 3px; font-family: 'Courier New', Courier, monospace; font-size: 0.75em; min-height: 18px; text-align: center; margin-bottom: 4px; border: 1px solid #111; }

        .keyboard { display: flex; justify-content: center; margin-top: 15px; padding: 8px; background-color: #333; border-radius: 5px; min-height: 110px; }
        .key { border: 1px solid #000; box-sizing: border-box; cursor: pointer; }
        .white-key { width: 28px; height: 100px; background-color: #fff; color: #000; z-index: 1; }
        .white-key.active, .white-key.qwerty-active { background-color: #ccc; } /* .active for sequencer/mouse */
        .black-key { width: 18px; height: 70px; background-color: #000; color: #fff; position: relative; margin-left: -9px; margin-right: -9px; z-index: 2; }
        .black-key.active, .black-key.qwerty-active { background-color: #333; }
        
        .flex-row-center { display: flex; justify-content: space-around; align-items: center; width: 100%;}
    </style>
</head>
<body>
    <div class="status-bar">
        <div class="midi-status" id="midi-status">Initializing...</div>
        <div class="main-message" id="main-message">Click to enable Audio & MIDI.</div>
    </div>

    <div class="synth-container">
        <!-- Row 1: Master, Osc1, Osc2, Mixer/FilterMain, Amp -->
        <div class="panel-row">
            <div class="section"> <!-- MASTER -->
                <h4 class="logo">KORG</h4>
                <div class="control-group"><label>VOLUME</label><div class="knob" id="volume-knob" data-param="volume"><div class="knob-indicator"></div></div></div>
                <label>Octave</label>
                <div class="octave-buttons flex-row-center">
                    <button id="octave-down">&lt;</button>
                    <span id="octave-display">0</span>
                    <button id="octave-up">&gt;</button>
                </div>
            </div>
            <div class="section"> <!-- OSC 1 -->
                <h4>OSC 1</h4>
                <div class="display small-display" id="osc1-display">SAW 0c</div>
                <div class="control-group"><label>TYPE</label><div class="knob" id="osc1-type-knob" data-param="osc1Type"><div class="knob-indicator"></div></div></div>
                <div class="control-group"><label>FINE TUNE</label><div class="knob" id="osc1-tune-fine-knob" data-param="osc1TuneFine"><div class="knob-indicator"></div></div></div>
            </div>
            <div class="section"> <!-- OSC 2 -->
                <h4>OSC 2</h4>
                <div class="display small-display" id="osc2-display">SAW 0s 0c</div>
                <div class="control-group"><label>TYPE</label><div class="knob" id="osc2-type-knob" data-param="osc2Type"><div class="knob-indicator"></div></div></div>
                <div class="flex-row-center">
                    <div class="control-group"><label>COARSE</label><div class="knob" id="osc2-tune-coarse-knob" data-param="osc2TuneCoarse"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>FINE</label><div class="knob" id="osc2-tune-fine-knob" data-param="osc2TuneFine"><div class="knob-indicator"></div></div></div>
                </div>
                <div class="control-group"><label>LEVEL</label><div class="knob" id="osc2-level-knob" data-param="osc2Level"><div class="knob-indicator"></div></div></div>
            </div>
            <div class="section"> <!-- MIXER / FILTER MAIN -->
                <h4>MIXER / FILTER</h4>
                <div class="display small-display" id="filter-display">LPF 8KHz Q1.0</div>
                <div class="flex-row-center">
                    <div class="control-group"><label>OSC MIX</label><div class="knob" id="osc-mix-knob" data-param="oscMix"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>FILT TYPE</label><div class="knob" id="filter-type-knob" data-param="filterType"><div class="knob-indicator"></div></div></div>
                </div>
                <div class="flex-row-center">
                     <div class="control-group"><label>CUTOFF</label><div class="knob" id="filter-cutoff-knob" data-param="filterCutoff"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>RESO</label><div class="knob" id="filter-reso-knob" data-param="filterReso"><div class="knob-indicator"></div></div></div>
                </div>
            </div>
             <div class="section"> <!-- AMP -->
                <h4>AMP</h4>
                <div class="control-group"><label>LEVEL</label><div class="knob" id="amp-level-knob" data-param="ampLevel"><div class="knob-indicator"></div></div></div>
                <button class="button" id="unison-btn" style="margin-top:10px;">UNISON</button>
            </div>
        </div>

        <!-- Row 2: LFO, Amp EG, Filter EG, Sequencer -->
        <div class="panel-row">
            <div class="section"> <!-- LFO -->
                <h4>LFO</h4>
                <div class="display small-display" id="lfo-display">SINE 5Hz</div>
                 <div class="flex-row-center">
                    <div class="control-group"><label>WAVE</label><div class="knob" id="lfo-wave-knob" data-param="lfoWave"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>FREQ</label><div class="knob" id="lfo-freq-knob" data-param="lfoFreq"><div class="knob-indicator"></div></div></div>
                </div>
                <div class="flex-row-center">
                    <div class="control-group"><label>FILT INT</label><div class="knob" id="lfo-filter-int-knob" data-param="lfoFilterInt"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>PITCH INT</label><div class="knob" id="lfo-pitch-int-knob" data-param="lfoPitchInt"><div class="knob-indicator"></div></div></div>
                </div>
            </div>
            <div class="section"> <!-- AMP EG -->
                <h4>AMP EG</h4>
                <div class="flex-row-center">
                    <div class="control-group"><label>ATTACK</label><div class="knob" id="env-a-knob" data-param="envA"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>DECAY</label><div class="knob" id="env-d-knob" data-param="envD"><div class="knob-indicator"></div></div></div>
                </div>
                <div class="flex-row-center">
                    <div class="control-group"><label>SUSTAIN</label><div class="knob" id="env-s-knob" data-param="envS"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>RELEASE</label><div class="knob" id="env-r-knob" data-param="envR"><div class="knob-indicator"></div></div></div>
                </div>
            </div>
            <div class="section"> <!-- FILTER EG -->
                <h4>FILTER EG</h4>
                <div class="flex-row-center">
                    <div class="control-group"><label>ATTACK</label><div class="knob" id="feg-a-knob" data-param="fegA"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>DECAY</label><div class="knob" id="feg-d-knob" data-param="fegD"><div class="knob-indicator"></div></div></div>
                </div>
                <div class="flex-row-center">
                    <div class="control-group"><label>SUSTAIN</label><div class="knob" id="feg-s-knob" data-param="fegS"><div class="knob-indicator"></div></div></div>
                    <div class="control-group"><label>RELEASE</label><div class="knob" id="feg-r-knob" data-param="fegR"><div class="knob-indicator"></div></div></div>
                </div>
                 <div class="control-group" style="margin-top:5px;"><label>AMOUNT</label><div class="knob" id="feg-amount-knob" data-param="fegAmount"><div class="knob-indicator"></div></div></div>
            </div>
            <div class="section"> <!-- SEQUENCER -->
                <h4>SEQUENCER</h4>
                <div class="display" id="sequencer-message-display">-</div>
                <div class="sequencer-controls">
                    <button id="record-btn">REC</button> <button id="play-btn">PLAY</button>
                    <button id="stop-btn">STOP</button>  <button id="loop-btn">LOOP</button>
                </div>
            </div>
        </div>
        <div class="keyboard" id="keyboard"></div>
    </div>

    <script>
        // --- CONSTANTS ---
        const MIDI_NOTE_ON = 0x90;
        const MIDI_NOTE_OFF = 0x80;
        const DEFAULT_VELOCITY = 0.7;
        const KNOB_RANGE_DEGREES = 270; 
        const KNOB_OFFSET_DEGREES = -135;
        const OSC_WAVEFORMS = ['sine', 'square', 'sawtooth', 'triangle'];
        const FILTER_TYPES_STR = ['lowpass', 'highpass', 'bandpass'];
        const ON_SCREEN_KEYBOARD_BASE_NOTE = 48; // C3
        const QWERTY_KEYBOARD_BASE_NOTE = 48;    // C3
        const QWERTY_KEY_MAP = {
            'KeyZ': 0,  'KeyX': 2,  'KeyC': 4,  'KeyV': 5,  'KeyB': 7,  'KeyN': 9,  'KeyM': 11, 'Comma': 12,
            'KeyS': 1,  'KeyD': 3,              'KeyG': 6,  'KeyH': 8,  'KeyJ': 10,
            'KeyQ': 12, 'KeyW': 14, 'KeyE': 16, 'KeyR': 17, 'KeyT': 19, 'KeyY': 21, 'KeyU': 23, 'KeyI': 24,
            'Digit2': 13,'Digit3': 15,             'Digit5': 18,'Digit6': 20,'Digit7': 22
        };

        // --- AUDIO CONTEXT & NODES ---
        let audioCtx; let masterGain;
        let osc1Node, osc1Gain; let osc2Node, osc2Gain;
        let filterNode; let ampEnvelopeGainNode; let fegModulatorNode;
        let lfoOscillatorNode, lfoFilterGainNode, lfoPitchGainNode;
        let currentPlayingMIDINote = null; 

        const synthParams = {}; 
        let uiElements = {}; 
        let sequencer = { isRecording: false, isPlaying: false, loopEnabled: false, sequence: [], recordingStartTime: 0, playbackTimeouts: [], activeVisualNotes: new Set() };
        let pressedQwertyKeys = {};

        // --- PARAMETER CONFIGURATION ---
        const PARAM_CONFIG = {
            volume:       { min: 0,    max: 1,    scale: 'linear', default: 0.3, audioUpdate: (v) => { if(masterGain) masterGain.gain.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            octave:       { min: -2,   max: 2,    scale: 'discrete', default: 0,   updateUI: (v) => { uiElements.octaveDisplay.textContent = v; createOnScreenKeyboard(); } },
            osc1Type:     { min: 0,    max: OSC_WAVEFORMS.length - 1, scale: 'discrete', default: 2, updateUI: updateOsc1Display, audioUpdate: (idx) => { if(osc1Node) osc1Node.type = OSC_WAVEFORMS[idx]; }},
            osc1TuneFine: { min: -100, max: 100,  scale: 'linear', default: 0,   updateUI: updateOsc1Display, audioUpdate: (v) => { if(osc1Node) osc1Node.detune.setTargetAtTime(v, audioCtx.currentTime, 0.005); }},
            osc2Type:     { min: 0,    max: OSC_WAVEFORMS.length - 1, scale: 'discrete', default: 2, updateUI: updateOsc2Display, audioUpdate: (idx) => { if(osc2Node) osc2Node.type = OSC_WAVEFORMS[idx]; }},
            osc2TuneCoarse:{ min: -24,  max: 24,   scale: 'discrete', default: 0,   updateUI: updateOsc2Display },
            osc2TuneFine: { min: -100, max: 100,  scale: 'linear', default: 0,   updateUI: updateOsc2Display, audioUpdate: (v) => { if(osc2Node) osc2Node.detune.setTargetAtTime(v, audioCtx.currentTime, 0.005); }},
            osc2Level:    { min: 0,    max: 1,    scale: 'linear', default: 0.7, audioUpdate: (v) => { if(osc2Gain) osc2Gain.gain.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            oscMix:       { min: 0,    max: 1,    scale: 'linear', default: 0.5, audioUpdate: (v) => { if(osc1Gain) osc1Gain.gain.setTargetAtTime(1 - v, audioCtx.currentTime, 0.01); if(osc2Gain) osc2Gain.gain.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            filterType:   { min: 0,    max: FILTER_TYPES_STR.length - 1, scale: 'discrete', default: 0, updateUI: updateFilterDisplay, audioUpdate: (idx) => { if(filterNode) filterNode.type = FILTER_TYPES_STR[idx]; }},
            filterCutoff: { min: 20,   max: 20000,scale: 'log',    default: 8000,updateUI: updateFilterDisplay, audioUpdate: (v) => { if(filterNode) filterNode.frequency.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            filterReso:   { min: 0.001,max: 30,   scale: 'linear', default: 1,   updateUI: updateFilterDisplay, audioUpdate: (v) => { if(filterNode) filterNode.Q.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            ampLevel:     { min: 0,    max: 1,    scale: 'linear', default: 0.7 },
            lfoWave:      { min: 0,    max: OSC_WAVEFORMS.length - 1, scale: 'discrete', default: 0, updateUI: updateLfoDisplay, audioUpdate: (idx) => { if(lfoOscillatorNode) lfoOscillatorNode.type = OSC_WAVEFORMS[idx]; }},
            lfoFreq:      { min: 0.1,  max: 20,   scale: 'log',    default: 5,   updateUI: updateLfoDisplay, audioUpdate: (v) => { if(lfoOscillatorNode) lfoOscillatorNode.frequency.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            lfoFilterInt: { min: 0,    max: 5000, scale: 'linear', default: 0,   audioUpdate: (v) => { if(lfoFilterGainNode) lfoFilterGainNode.gain.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            lfoPitchInt:  { min: 0,    max: 1200, scale: 'linear', default: 0,   audioUpdate: (v) => { if(lfoPitchGainNode) lfoPitchGainNode.gain.setTargetAtTime(v, audioCtx.currentTime, 0.01); }},
            envA:         { min: 0.001,max: 2,    scale: 'sqrt',   default: 0.01}, envD: { min: 0.001,max: 2, scale: 'sqrt', default: 0.1 },
            envS:         { min: 0,    max: 1,    scale: 'linear', default: 0.8 }, envR: { min: 0.001,max: 2, scale: 'sqrt', default: 0.2 },
            fegA:         { min: 0.001,max: 2,    scale: 'sqrt',   default: 0.02}, fegD: { min: 0.001,max: 2, scale: 'sqrt', default: 0.2 },
            fegS:         { min: 0,    max: 1,    scale: 'linear', default: 0.5 }, fegR: { min: 0.001,max: 2, scale: 'sqrt', default: 0.3 },
            fegAmount:    { min: -8000,max: 8000, scale: 'linear', default: 0   }
        };
        
        document.addEventListener('DOMContentLoaded', initializeSynth);

        function initializeSynth() {
            cacheUIElements();
            initializeParameters();
            setupEventListeners();
            createOnScreenKeyboard();
            updateAllDisplays(); 
            uiElements.mainMessage.textContent = "Click to enable Audio & MIDI. (QWERTY: ZSX... ASDF...)";
        }

        function initializeParameters() {
            for (const paramKey in PARAM_CONFIG) {
                synthParams[paramKey] = PARAM_CONFIG[paramKey].default;
            }
        }
        
        function initializeAudioAndMIDI() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.setValueAtTime(synthParams.volume, audioCtx.currentTime);
                masterGain.connect(audioCtx.destination);

                osc1Gain = audioCtx.createGain();
                osc2Gain = audioCtx.createGain();
                applyOscMix(); // Set initial mix based on synthParams

                filterNode = audioCtx.createBiquadFilter();
                filterNode.type = FILTER_TYPES_STR[synthParams.filterType];
                filterNode.frequency.setValueAtTime(synthParams.filterCutoff, audioCtx.currentTime);
                filterNode.Q.setValueAtTime(synthParams.filterReso, audioCtx.currentTime);
                
                ampEnvelopeGainNode = audioCtx.createGain();
                ampEnvelopeGainNode.gain.setValueAtTime(0, audioCtx.currentTime);

                osc1Gain.connect(ampEnvelopeGainNode);
                osc2Gain.connect(ampEnvelopeGainNode);
                ampEnvelopeGainNode.connect(filterNode);
                filterNode.connect(masterGain);

                fegModulatorNode = audioCtx.createGain(); 
                fegModulatorNode.gain.setValueAtTime(0, audioCtx.currentTime); 
                fegModulatorNode.connect(filterNode.frequency);

                lfoOscillatorNode = audioCtx.createOscillator();
                lfoOscillatorNode.type = OSC_WAVEFORMS[synthParams.lfoWave];
                lfoOscillatorNode.frequency.setValueAtTime(synthParams.lfoFreq, audioCtx.currentTime);
                
                lfoFilterGainNode = audioCtx.createGain();
                lfoFilterGainNode.gain.setValueAtTime(synthParams.lfoFilterInt, audioCtx.currentTime);
                lfoOscillatorNode.connect(lfoFilterGainNode);

                lfoPitchGainNode = audioCtx.createGain();
                lfoPitchGainNode.gain.setValueAtTime(synthParams.lfoPitchInt, audioCtx.currentTime);
                lfoOscillatorNode.connect(lfoPitchGainNode);
                
                lfoOscillatorNode.start();
                
                uiElements.midistatus.textContent = "Audio OK. Setting up MIDI...";
                setupMIDI();
                uiElements.mainMessage.textContent = "Synth Ready!";
            } catch (e) { uiElements.midistatus.textContent = "Audio Error!"; uiElements.mainMessage.textContent = "Error: " + e.message.substring(0, 50); console.error(e); }
        }
        
        function applyOscMix() { // Helper to apply mix based on current params
            if (!osc1Gain || !osc2Gain) return;
            osc1Gain.gain.setTargetAtTime(1 - synthParams.oscMix, audioCtx.currentTime, 0.005);
            osc2Gain.gain.setTargetAtTime(synthParams.oscMix * synthParams.osc2Level, audioCtx.currentTime, 0.005); // Apply osc2Level here
        }
        PARAM_CONFIG.oscMix.audioUpdate = applyOscMix; // Override default behavior
        PARAM_CONFIG.osc2Level.audioUpdate = applyOscMix; // Level change also affects mix application


        function triggerNoteOn(midiNote, velocity, source = 'midi') {
            if (!audioCtx) return;
            const time = audioCtx.currentTime;

            if (osc1Node) { // Monophonic: Stop existing note
                const quickRelease = 0.01;
                ampEnvelopeGainNode.gain.cancelScheduledValues(time);
                ampEnvelopeGainNode.gain.setTargetAtTime(0, time, quickRelease);
                fegModulatorNode.gain.cancelScheduledValues(time);
                fegModulatorNode.gain.setTargetAtTime(0, time, quickRelease);
                osc1Node.stop(time + quickRelease + 0.01);
                if (osc2Node) osc2Node.stop(time + quickRelease + 0.01);
            }
            currentPlayingMIDINote = midiNote;

            osc1Node = audioCtx.createOscillator();
            osc1Node.type = OSC_WAVEFORMS[synthParams.osc1Type];
            osc1Node.frequency.setValueAtTime(midiNoteToFrequency(midiNote), time);
            osc1Node.detune.setValueAtTime(synthParams.osc1TuneFine, time);
            osc1Node.connect(osc1Gain);
            osc1Node.start(time);

            osc2Node = audioCtx.createOscillator();
            osc2Node.type = OSC_WAVEFORMS[synthParams.osc2Type];
            osc2Node.frequency.setValueAtTime(midiNoteToFrequency(midiNote + synthParams.osc2TuneCoarse), time);
            osc2Node.detune.setValueAtTime(synthParams.osc2TuneFine, time);
            osc2Node.connect(osc2Gain);
            osc2Node.start(time);
            
            applyOscMix(); // Ensure mix is correct for new oscillators

            ampEnvelopeGainNode.gain.cancelScheduledValues(time);
            ampEnvelopeGainNode.gain.setValueAtTime(0, time);
            ampEnvelopeGainNode.gain.linearRampToValueAtTime(synthParams.ampLevel * velocity, time + synthParams.envA);
            ampEnvelopeGainNode.gain.linearRampToValueAtTime(synthParams.envS * synthParams.ampLevel * velocity, time + synthParams.envA + synthParams.envD);

            fegModulatorNode.gain.cancelScheduledValues(time);
            fegModulatorNode.gain.setValueAtTime(0, time);
            fegModulatorNode.gain.linearRampToValueAtTime(1.0 * synthParams.fegAmount, time + synthParams.fegA);
            fegModulatorNode.gain.linearRampToValueAtTime(synthParams.fegS * synthParams.fegAmount, time + synthParams.fegA + synthParams.fegD);

            if (synthParams.lfoFilterInt !== 0) { lfoFilterGainNode.disconnect(); lfoFilterGainNode.connect(filterNode.frequency); } else { lfoFilterGainNode.disconnect(); }
            if (synthParams.lfoPitchInt !== 0) {
                lfoPitchGainNode.disconnect();
                if(osc1Node && osc1Node.detune) lfoPitchGainNode.connect(osc1Node.detune);
                if(osc2Node && osc2Node.detune) lfoPitchGainNode.connect(osc2Node.detune);
            } else { lfoPitchGainNode.disconnect(); }
            
            if (sequencer.isRecording && (source === 'midi' || source === 'qwerty' || source === 'onscreen')) {
                sequencer.sequence.push({ time: audioCtx.currentTime - sequencer.recordingStartTime, type: 'noteon', note: midiNote, velocity: velocity });
            }
        }

        function triggerNoteOff(midiNote, source = 'midi') {
            if (!osc1Node || currentPlayingMIDINote !== midiNote) return;
            const time = audioCtx.currentTime;

            ampEnvelopeGainNode.gain.cancelScheduledValues(time);
            ampEnvelopeGainNode.gain.setValueAtTime(ampEnvelopeGainNode.gain.value, time); 
            ampEnvelopeGainNode.gain.linearRampToValueAtTime(0, time + synthParams.envR);

            fegModulatorNode.gain.cancelScheduledValues(time);
            fegModulatorNode.gain.setValueAtTime(fegModulatorNode.gain.value, time);
            fegModulatorNode.gain.linearRampToValueAtTime(0, time + synthParams.fegR);

            const stopTime = time + Math.max(synthParams.envR, synthParams.fegR) + 0.05;
            osc1Node.stop(stopTime);
            if (osc2Node) osc2Node.stop(stopTime);
            
            osc1Node.onended = () => { // Cleanup LFOs after sound fully stops
                if (lfoFilterGainNode) lfoFilterGainNode.disconnect();
                if (lfoPitchGainNode) lfoPitchGainNode.disconnect();
            };
            osc1Node = null; osc2Node = null; currentPlayingMIDINote = null;
            
            if (sequencer.isRecording && (source === 'midi' || source === 'qwerty' || source === 'onscreen')) {
                sequencer.sequence.push({ time: audioCtx.currentTime - sequencer.recordingStartTime, type: 'noteoff', note: midiNote });
            }
        }
        
        function updateOsc1Display() { uiElements.osc1display.textContent = `${OSC_WAVEFORMS[synthParams.osc1Type].toUpperCase()} ${synthParams.osc1TuneFine.toFixed(0)}c`; }
        function updateOsc2Display() { uiElements.osc2display.textContent = `${OSC_WAVEFORMS[synthParams.osc2Type].toUpperCase()} ${synthParams.osc2TuneCoarse}s ${synthParams.osc2TuneFine.toFixed(0)}c`; }
        function updateFilterDisplay() {  uiElements.filterdisplay.textContent = `${FILTER_TYPES_STR[synthParams.filterType].toUpperCase()} ${synthParams.filterCutoff.toFixed(0)}Hz Q${synthParams.filterReso.toFixed(1)}`; }
        function updateLfoDisplay() { uiElements.lfodisplay.textContent = `${OSC_WAVEFORMS[synthParams.lfoWave].toUpperCase()} ${synthParams.lfoFreq.toFixed(1)}Hz`; }
        
        function updateAllDisplays() {
            for (const paramKey in PARAM_CONFIG) {
                const config = PARAM_CONFIG[paramKey];
                if (config.updateUI) config.updateUI(synthParams[paramKey]); // Pass the direct synthParam value (index for discrete)
            }
        }
        
        // --- Knob Interaction (applyParamChange needs to set synthParams[paramKey] to INDEX for discrete types) ---
        function applyParamChange(paramKey, normalizedValue) {
            const config = PARAM_CONFIG[paramKey]; let actualValue;
            if (config.scale === 'discrete') {
                actualValue = Math.round(normalizedValue * (config.max - config.min)) + config.min;
                actualValue = Math.max(config.min, Math.min(config.max, actualValue)); 
                synthParams[paramKey] = actualValue; // Store INDEX for discrete types
            } else if (config.scale === 'log') { const minLog = Math.log(config.min || 0.001); const maxLog = Math.log(config.max); actualValue = Math.exp(minLog + (maxLog - minLog) * normalizedValue); synthParams[paramKey] = Math.max(config.min, Math.min(config.max, actualValue));}
            else if (config.scale === 'sqrt') { actualValue = Math.pow(normalizedValue, 2) * (config.max - config.min) + config.min; synthParams[paramKey] = Math.max(config.min, Math.min(config.max, actualValue));}
            else { actualValue = normalizedValue * (config.max - config.min) + config.min; synthParams[paramKey] = Math.max(config.min, Math.min(config.max, actualValue));}
            
            if (config.audioUpdate) config.audioUpdate(synthParams[paramKey]);
            if (config.updateUI) config.updateUI(synthParams[paramKey]);
        }

        // --- SEQUENCER LOGIC (Carefully reviewed) ---
        function toggleRecording() {
            if (!audioCtx) initializeAudioAndMIDI();
            if (sequencer.isPlaying) stopSequence(); 
            sequencer.isRecording = !sequencer.isRecording;
            if (sequencer.isRecording) { sequencer.sequence = []; sequencer.recordingStartTime = audioCtx.currentTime; }
            updateSequencerUI();
        }

        function playSequence() {
            if (sequencer.isRecording) { uiElements.sequencermessagedisplay.textContent = "Stop REC first"; return; }
            if (sequencer.sequence.length === 0) { uiElements.sequencermessagedisplay.textContent = "No sequence"; return; }
            
            if (sequencer.isPlaying) stopSequence(); // Stop current playback cleanly before restarting

            sequencer.isPlaying = true;
            updateSequencerUI();
            const sequencePlaybackStartTime = audioCtx.currentTime;
            sequencer.activeVisualNotes.clear(); // Clear any visually stuck notes from previous plays

            sequencer.sequence.forEach(event => {
                const scheduledTime = sequencePlaybackStartTime + event.time;
                const delay = Math.max(0, (scheduledTime - audioCtx.currentTime) * 1000);

                const timeoutId = setTimeout(() => {
                    if (!sequencer.isPlaying && !sequencer.loopEnabled) return; // Abort if stopped and not looping

                    const keyEl = uiElements.keyboard.querySelector(`.key[data-note-val="${event.note}"]`);
                    if (event.type === 'noteon') {
                        if(sequencer.isPlaying || sequencer.loopEnabled) triggerNoteOn(event.note, event.velocity, 'sequencer');
                        if (keyEl) keyEl.classList.add('active');
                        sequencer.activeVisualNotes.add(event.note);
                    } else if (event.type === 'noteoff') {
                        // Note off should always try to fire if it was part of a play, even if main playback stopped before loop
                        triggerNoteOff(event.note, 'sequencer');
                        if (keyEl) keyEl.classList.remove('active');
                        sequencer.activeVisualNotes.delete(event.note);
                    }
                }, delay);
                sequencer.playbackTimeouts.push(timeoutId);
            });

            if (sequencer.sequence.length > 0) {
                const lastEventTime = sequencer.sequence.reduce((max, e) => Math.max(max, e.time), 0);
                const longestRelease = Math.max(synthParams.envR, synthParams.fegR) + 0.15; // Ensure tails complete
                const sequenceDurationMs = (lastEventTime + longestRelease) * 1000;

                const endPlaybackTimeoutId = setTimeout(() => {
                    if (!sequencer.isPlaying) return; // Stopped manually

                    sequencer.isPlaying = false; // Current iteration finished
                    if (sequencer.loopEnabled) {
                        playSequence(); // Restart for loop
                    } else {
                        updateSequencerUI(); // Update to non-playing state
                    }
                }, sequenceDurationMs);
                sequencer.playbackTimeouts.push(endPlaybackTimeoutId);
            } else { // Should not happen if guarded above
                 sequencer.isPlaying = false; updateSequencerUI();
            }
        }

        function stopSequence() {
            const wasPlaying = sequencer.isPlaying;
            sequencer.isPlaying = false;
            if (sequencer.isRecording) sequencer.isRecording = false;
            
            sequencer.playbackTimeouts.forEach(clearTimeout);
            sequencer.playbackTimeouts = [];

            if (currentPlayingMIDINote !== null) { // If a note was audibly playing (from sequencer or live)
                triggerNoteOff(currentPlayingMIDINote, 'system_stop'); 
            }
            // Clear all visual active states that the sequencer might have set
            sequencer.activeVisualNotes.forEach(noteVal => {
                const keyEl = uiElements.keyboard.querySelector(`.key[data-note-val="${noteVal}"]`);
                if (keyEl) keyEl.classList.remove('active');
            });
            sequencer.activeVisualNotes.clear();
            
            updateSequencerUI();
        }

        function toggleLoop() { sequencer.loopEnabled = !sequencer.loopEnabled; updateSequencerUI(); }
        function updateSequencerUI() { /* ... Same as before, uses sequencer object state ... */ 
            uiElements.recordbtn.classList.toggle('recording', sequencer.isRecording);
            uiElements.recordbtn.textContent = sequencer.isRecording ? "REC ON" : "REC";
            uiElements.playbtn.classList.toggle('playing', sequencer.isPlaying);
            uiElements.playbtn.textContent = sequencer.isPlaying ? "PLAYING" : "PLAY";
            uiElements.loopbtn.classList.toggle('active', sequencer.loopEnabled);
            uiElements.loopbtn.textContent = sequencer.loopEnabled ? "LOOP ON" : "LOOP";
            let message = "-";
            if(sequencer.isRecording) message = "Recording...";
            else if(sequencer.isPlaying) message = "Playing...";
            else if(sequencer.sequence.length > 0) message = `Seq: ${sequencer.sequence.length} events`;
            uiElements.sequencermessagedisplay.textContent = message;
        }

        // --- All other functions (MIDI, QWERTY, Knob Helpers, OnScreenKeyboard, etc.) ---
        // ... (Should largely remain the same, ensure they use new structure)
        function cacheUIElements() { /* ... same, ensure all IDs match HTML ... */ 
            const ids = [ 'midi-status', 'main-message', 'octave-display', 'osc1-display', 'osc2-display', 'filter-display', 'lfo-display', 'keyboard', 'sequencer-message-display', 'record-btn', 'play-btn', 'stop-btn', 'loop-btn', 'unison-btn', 'octave-up', 'octave-down' ];
            ids.forEach(id => uiElements[id.replace(/-/g, '')] = document.getElementById(id));
            uiElements.knobs = document.querySelectorAll('.knob');
        }
        function setupEventListeners() { /* ... same ... */ 
            document.body.addEventListener('click', initializeAudioAndMIDI, { once: true });
            uiElements.knobs.forEach(makeKnobInteractive);
            uiElements.octaveup.addEventListener('click', () => changeOctave(1));
            uiElements.octavedown.addEventListener('click', () => changeOctave(-1));
            uiElements.unisonbtn.addEventListener('click', toggleUnison);
            uiElements.recordbtn.addEventListener('click', toggleRecording);
            uiElements.playbtn.addEventListener('click', playSequence);
            uiElements.stopbtn.addEventListener('click', stopSequence);
            uiElements.loopbtn.addEventListener('click', toggleLoop);
            document.addEventListener('keydown', handleQwertyKeyDown);
            document.addEventListener('keyup', handleQwertyKeyUp);
        }
        function setupMIDI() { /* ... Same ... */ if (navigator.requestMIDIAccess) { navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure); } else { uiElements.midistatus.textContent = 'Web MIDI API not supported.'; } }
        function onMIDISuccess(midiAccess) { /* ... Same ... */ let inputs = midiAccess.inputs; if (inputs.size > 0) { let Ns = []; inputs.forEach(i => { i.onmidimessage = handleMIDIMessage; Ns.push(i.name); }); uiElements.midistatus.textContent = `MIDI: ${Ns.join(', ')}`; } else { uiElements.midistatus.textContent = 'MIDI: No devices found.'; } }
        function onMIDIFailure() { uiElements.midistatus.textContent = 'MIDI access failed.'; }
        function handleMIDIMessage(message) { /* ... Same, calls triggerNoteOn/Off ... */ if (!audioCtx) initializeAudioAndMIDI(); const [cmd, n, vel] = message.data; const cmdT = cmd & 0xF0; if (cmdT === MIDI_NOTE_ON && vel > 0) { triggerNoteOn(n, vel / 127); } else if (cmdT === MIDI_NOTE_OFF || (cmdT === MIDI_NOTE_ON && vel === 0)) { triggerNoteOff(n); } }
        function handleQwertyKeyDown(e) { /* ... Same, calls triggerNoteOn ... */ if (e.repeat || !QWERTY_KEY_MAP.hasOwnProperty(e.code) || pressedQwertyKeys[e.code]) return; if (!audioCtx) initializeAudioAndMIDI(); const mO = QWERTY_KEY_MAP[e.code]; const mN = QWERTY_KEYBOARD_BASE_NOTE + mO + (synthParams.octave * 12); pressedQwertyKeys[e.code] = mN; triggerNoteOn(mN, DEFAULT_VELOCITY, 'qwerty'); const kEl = uiElements.keyboard.querySelector(`.key[data-note-val="${mN}"]`); if (kEl) kEl.classList.add('qwerty-active'); }
        function handleQwertyKeyUp(e) { /* ... Same, calls triggerNoteOff ... */ if (!QWERTY_KEY_MAP.hasOwnProperty(e.code) || !pressedQwertyKeys[e.code]) return; const mN = pressedQwertyKeys[e.code]; triggerNoteOff(mN, 'qwerty'); delete pressedQwertyKeys[e.code]; const kEl = uiElements.keyboard.querySelector(`.key[data-note-val="${mN}"]`); if (kEl) kEl.classList.remove('qwerty-active'); }
        function midiNoteToFrequency(midiNote) { return 440 * Math.pow(2, (midiNote - 69) / 12); }
        const ON_SCREEN_NOTE_DEFS = [ { name: 'C', midiOffset: 0, type: 'white' }, { name: 'C#', midiOffset: 1, type: 'black' }, { name: 'D', midiOffset: 2, type: 'white' }, { name: 'D#', midiOffset: 3, type: 'black' }, { name: 'E', midiOffset: 4, type: 'white' }, { name: 'F', midiOffset: 5, type: 'white' }, { name: 'F#', midiOffset: 6, type: 'black' }, { name: 'G', midiOffset: 7, type: 'white' }, { name: 'G#', midiOffset: 8, type: 'black' }, { name: 'A', midiOffset: 9, type: 'white' }, { name: 'A#', midiOffset: 10, type: 'black' }, { name: 'B', midiOffset: 11, type: 'white' }, { name: 'C5', nameDisplay: 'C', midiOffset: 12, type: 'white'} ];
        function createOnScreenKeyboard() { /* ... Same ... */ uiElements.keyboard.innerHTML = ''; ON_SCREEN_NOTE_DEFS.forEach((nD) => { const kE = document.createElement('div'); kE.classList.add('key', nD.type === 'white' ? 'white-key' : 'black-key'); const mNV = ON_SCREEN_KEYBOARD_BASE_NOTE + nD.midiOffset + (synthParams.octave * 12); kE.dataset.noteVal = mNV; kE.addEventListener('mousedown', (e) => { e.preventDefault(); if (!audioCtx) initializeAudioAndMIDI(); triggerNoteOn(mNV, DEFAULT_VELOCITY, 'onscreen'); kE.classList.add('active'); }); kE.addEventListener('mouseup', (e) => { e.preventDefault(); triggerNoteOff(mNV, 'onscreen'); kE.classList.remove('active'); }); kE.addEventListener('mouseleave', (e) => { e.preventDefault(); if (kE.classList.contains('active')) { triggerNoteOff(mNV, 'onscreen'); kE.classList.remove('active'); } }); uiElements.keyboard.appendChild(kE); }); }
        function makeKnobInteractive(knobElement) { /* ... Same logic, relies on PARAM_CONFIG ... */ const pK = knobElement.dataset.param; if (!pK || !PARAM_CONFIG[pK]) return; const c = PARAM_CONFIG[pK]; const ind = knobElement.querySelector('.knob-indicator'); let iD = false; let sY, sNV; updateKnobIndicator(ind, getNormalizedValue(synthParams[pK], c), c.scale); knobElement.addEventListener('mousedown', (e) => { e.preventDefault(); if (!audioCtx && pK !== 'volume') initializeAudioAndMIDI(); iD = true; sY = e.clientY; sNV = getNormalizedValue(synthParams[pK], c); knobElement.style.cursor = 'grabbing'; document.body.style.cursor = 'grabbing'; }); document.addEventListener('mousemove', (e) => { if (!iD) return; e.preventDefault(); const dY = sY - e.clientY; const sens = (c.scale === 'discrete' || c.max - c.min <= 24) ? 0.003 : 0.007; let nNV = Math.max(0, Math.min(1, sNV + dY * sens)); updateKnobIndicator(ind, nNV, c.scale); applyParamChange(pK, nNV); }); document.addEventListener('mouseup', (e) => { if (iD) { e.preventDefault(); iD = false; knobElement.style.cursor = 'grab'; document.body.style.cursor = 'default'; } }); }
        function getNormalizedValue(actualValue, config) { /* ... Same ... */ if (config.scale === 'discrete') { return (actualValue - config.min) / (config.max - config.min || 1); } else if (config.scale === 'log') { const min = config.min <= 0 ? 0.001 : config.min; return (Math.log(actualValue / min)) / (Math.log(config.max / min)); } else if (config.scale === 'sqrt') { return Math.sqrt((actualValue - config.min) / (config.max - config.min || 1)); } return (actualValue - config.min) / (config.max - config.min || 1); }
        function updateKnobIndicator(indicator, normalizedValue, scaleType) { /* ... Same ... */ if (!indicator) return; const angle = (normalizedValue * KNOB_RANGE_DEGREES) + KNOB_OFFSET_DEGREES; indicator.style.transform = `rotate(${angle}deg)`; }
        function changeOctave(delta) { if (!audioCtx) initializeAudioAndMIDI(); const nO = Math.max(PARAM_CONFIG.octave.min, Math.min(PARAM_CONFIG.octave.max, synthParams.octave + delta)); if (nO !== synthParams.octave) { synthParams.octave = nO; PARAM_CONFIG.octave.updateUI(nO); } }
        function toggleUnison() { uiElements.unisonbtn.classList.toggle('active'); }

    </script>
</body>
</html>
